#' Fit the envelope based PLS.
#'
#' This function fits the envelope model to the responses and predictors,
#' using the maximum likelihood estimation. When the dimension of the envelope is between
#' 1 and p-1, we implemented the algorithm in Cook et al (2013). When the dimension
#' is p, then the envelope model degenerates to the standard multivariate linear regression.
#' When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
#'
#'
#' @param X Predictors. An n by p matrix, p is the number of predictors.
#'        The predictors can be univariate or multivariate, discrete or continuous.
#'
#' @param Y Multivariate responses. An n by r matrix, r is the number of responses and
#'        n is the number of observations. The responses must be continuous variables.
#'
#' @param u Dimension of the envelope. An integer between 0 and p.
#'
#' @param maxIter Maximum number of iterations. Default value: 100.
#'
#' @param ftol Tolerance parameter for F. Default value: 1e-3.
#'
#' @param verbose Flag for print out model fitting process, logical 0 or 1. Default value: 0.
#'
#' @param asym Flag for calculating the asymptotic covariance of vec(beta) and asymptotic standard
#'        error for elements in beta for a fitted envelope model, logical 0 or 1. Default value: 0.
#'
#' @param init The initial value for the envelope subspace. An p by u matrix.
#        Default value is the one generated by function get_Init.
#'
#' @return A list containing the following components:#'
#' \item{mu}{The estimated intercept in the envelope model. An r by 1 vector.}
#' \item{beta}{The envelope estimator of the regression coefficients beta. A p by r matrix.}
#' \item{Gamma}{The orthogonal basis of the envelope subspace. An p by u semi-orthogonal matrix.}
#' \item{Gamma0}{The orthogonal basis of the complement of the envelope subspace. An p by p-u semi-orthogonal matrix.}
#' \item{eta}{The coordinates of beta with respect to Gamma. A u by r matrix.}
#' \item{SigX}{The envelope estimator of the covariance matrix of X. An p by p matrix.}
#' \item{Omega}{The coordinates of Sigma with respect to Gamma. A u by u matrix.}
#' \item{Omega0}{The coordinates of Sigma with respect to Gamma0. An p-u by p-u matrix.}
#' \item{sigYcX}{The estimated conditional covariance matrix of Y given X. An r by r matrix.}
#' \item{loglik}{The maximized log likelihood function. A real number.}
#' \item{covMatrix}{The asymptotic covariance of vec(beta). An pr by pr matrix. The covariance matrix returned are asymptotic.
#' For the actual standard errors, multiply by 1/n.}
#' \item{asySE}{The asymptotic standard error for elements in beta under the envelope model. An p by r matrix.
#' The standard errors returned are asymptotic, for actual standard errors, multiply by 1/sqrt(n).}
#' \item{ratio}{The asymptotic standard error ratio of the standard multivariate linear regression estimator over the envelope estimator,
#' for each element in beta. An r by p matrix.}
#' \item{paramNum}{The number of parameters in the envelope model. A positive integer.}
#' \item{n}{The number of observations in the data. A positive integer.}
#' \item{fit_time}{The time costs for fitting the envelope model.}
#'
#' @references
#' Cook, R. D., Helland, I. S. and Su, Z. (2013), Envelopes and Partial Least Squares Regression.
#' Journal of the Royal Statistical Society: Series B, 75, 851-877.
#'
#' The codes are implemented based on the algorithm in Cook, R. D., Forzani, L. and Su, Z. (2016), A Note on Fast Envelope Estimation.
#' Journal of Multivariate Analysis. 150, 42-54.
#'
#' @author
#' Guangyu Zhu and Zhihua Su
#'
#' @seealso \code{choose_xenv} for choosing the dimension of the envelope subspace.
#'
#' @examples
#' data(AIS)
#' m1 = xenv(AIS$X, AIS$Y, 1)
#' @export
xenv <- function(X, Y, u,maxiter = 1e2,ftol=1e-3,init=NULL,asy=0,verbose=0,init_method=1,lambda_spice=0.1) {
  t1 = proc.time()
  X <- as.matrix(X)
  Y <- as.matrix(Y)
  n <- nrow(Y)
  r <- ncol(Y)
  p <- ncol(X)
  mX = colMeans(X)
  mY = colMeans(Y)
  Yc <- as.matrix(scale(Y, center = T, scale = FALSE))
  Xc <- as.matrix(scale(X, center = T, scale = FALSE))

  sigY <- stats::cov(Yc) * (n-1)/n
  sigX <- stats::cov(Xc) * (n-1)/n
  sigXY <- stats::cov(Xc, Yc) * (n-1)/n

  tmp = chol(sigX) # t(tmp)%*%tmp =sigX
  invsigX <- chol2inv(tmp) # invsigX=tmp2%*%t(tmp2)
  invsigXL <- backsolve(tmp, diag(p)) # tmp2=inv(tmp)
  tmp3 <- crossprod(sigXY, invsigXL)
  sigYcX = sigY - tcrossprod(tmp3,tmp3) #sigYX %*% invsigX%*% t(sigYX)


  tmp = chol(sigY) # t(tmp)%*%tmp =sigY
  invsigY <- chol2inv(tmp) # invsigY=tmp2%*%t(tmp2)
  tmp2 <- backsolve(tmp, diag(r)) # tmp2=inv(tmp)
  tmp3 <- sigXY %*% tmp2
  U <- tcrossprod(tmp3,tmp3) #sigXY %*% invsigY%*% t(sigXY)
  sigXcY <- sigX - U
  sigXcYL = t(chol(sigXcY))

  betaOLS <- invsigX%*%sigXY
  logDetsigY = logdet(sigY)
  logDetsigX = logdet(sigX)
  ModelOutput=list()

  if(u == 0){
    ModelOutput$mu = mY;
    ModelOutput$beta = matrix(0,p, r)
    ModelOutput$Gamma = NULL
    ModelOutput$Gamma0 = diag(p);
    ModelOutput$eta = NULL;
    ModelOutput$SigX = sigX
    ModelOutput$Omega = NULL;
    ModelOutput$Omega0 = sigX;
    ModelOutput$loglik = - n * (r + p) / 2 * (1 + log(2 * pi)) - n / 2 *  (logDetsigX + logDetsigY);
    ModelOutput$paramNum = r + p * (p + 1) / 2 + r * (r + 1) / 2;
    ModelOutput$n = n;
    if(asy==1){
      ModelOutput$covMatrix = NULL;
      ModelOutput$asySE = NULL;
      ModelOutput$ratio = matrix(1,p, r);
    }
  }
  else if (u == p){
    beta = betaOLS
    ModelOutput$mu = mY - t(beta) %*% mX
    ModelOutput$beta = beta;
    ModelOutput$Gamma = diag(p)
    ModelOutput$Gamma0 = NULL
    ModelOutput$eta = beta
    ModelOutput$SigX = sigX;
    ModelOutput$Omega = sigX
    ModelOutput$Omega0 = NULL
    ModelOutput$loglik =  -n * (p + r) * (1 + log(2 * pi)) / 2 - n / 2 * (logDetsigY + logdet(sigXcY));
    ModelOutput$paramNum = r + (p + r) * (p + r + 1) / 2;
    ModelOutput$n = n
    if(asy==1){
      covMatrix = kronecker(sigYcX, invsigX);
      asyFm = matrix(sqrt(diag(covMatrix)), p,r);
      ModelOutput$covMatrix = covMatrix
      ModelOutput$asySE = asyFm
      ModelOutput$ratio = matrix(1, p, r)
    }
  }
  else{
    if(missing(init)){
      if(init_method==1){init=initial_value(Y,X,u)}
      else if(init_method==2) {spice<-spxenv_spice(X,Y,lambda=lambda_spice);init=get_Init(spice$sigXcY,spice$sigX-spice$sigXcY,u)}
      else if(init_method==3)  {init=initial_spls(X,Y,u)}
      else if(init_method==4) {init = unclass(pls::plsr(Y~X,ncomp=u)$loadings)}
    }
    Ginit <- init %*% solve(init[1:u, ])
    if(u == (p-1)) # now the G is a u-1 by u-1 identity matrix
    {
      U1c2 <- array(0, dim = c(p-1, p-1))
      V1c2 <- array(0, dim = c(p-1, p-1))

      U1c2 <- sigXcY[-p, -p] - as.matrix(sigXcY[-p, p]) %*% sigXcY[p, -p] / sigXcY[p, p]
      V1c2 <- invsigX[-p, -p] - as.matrix(invsigX[-p, p]) %*% invsigX[p, -p] / invsigX[p, p]

      t2 <- sigXcY[-p, p] / sigXcY[p, p] # p-1 by 1
      t3 <- invsigX[-p, p] / invsigX[p, p] # p-1 by 1
      invC1 <- chol2inv(chol(U1c2)) # p-1 by p-1
      invC2 <- chol2inv(chol(V1c2)) # p-1 by p-1

      fobj <- function(x){
        tmp2 <- x + t2
        tmp3 <- x + t3
        T2 <- invC1 %*% tmp2
        T3 <- invC2 %*% tmp3
        -2 * log(1 + sum(x^2)) + log(1 + sigXcY[p, p] * crossprod(tmp2, T2)) + log(1 + invsigX[p, p] * crossprod(tmp3, T3))
      }

      gobj <- function(x){
        tmp2 <- x + t2
        tmp3 <- x + t3
        T2 <- invC1 %*% tmp2
        T3 <- invC2 %*% tmp3
        -4 * x %*% solve(1 + sum(x^2)) + 2 * T2 / as.numeric(1 / sigXcY[p, p] + crossprod(tmp2, T2)) + 2 * T3 / as.numeric(1 / invsigX[p, p] + crossprod(tmp3, T3))
      }

      i <- 1
      while (i < maxiter) {
        res <- optim(Ginit[p, ], fobj, gobj, method = "BFGS",control=list(reltol=1e-2))
        if (abs(fobj(Ginit[p,]) - fobj(res$par)) < ftol * fobj(Ginit[p,])) {
          Ginit[p,] <- res$par
          break
        } else {
          Ginit[p,] <- res$par
          i <- i + 1
        }
      }
      if(verbose) cat('The number of iterations:',i,'.\n',sep='')
      a <- qr.Q(qr(Ginit), complete = TRUE)
      Gamma <- a[, 1:u]
      Gamma0 <- a[, p]
    }
    else {
      obj<-function(R){
        tmp1=crossprod(R,sigXcYL)
        tmp2=crossprod(R,invsigXL)
        logdet(tcrossprod(tmp1,tmp1))+logdet(tcrossprod(tmp2,tmp2))
      }
      obj1=obj(init)

      tmp1=crossprod(Ginit,sigXcYL)
      tmp2=crossprod(Ginit,invsigXL)
      GUG <- tcrossprod(tmp1,tmp1)
      GVG <- tcrossprod(tmp2,tmp2)
      if(!isSymmetric(GUG)) print('GUG is not symme')
      if(!isSymmetric(GVG)) print('GVG is not symme')

      t4 <- crossprod(Ginit[(u+1):p,], Ginit[(u+1):p, ]) + diag(u)
      i <- 1
      while (i < maxiter) {
        for (j in (u+1):p) {
          g <- as.matrix(Ginit[j, ])
          t2 <- crossprod(Ginit[-j, ], as.matrix(sigXcY[-j, j])) / sigXcY[j, j]
          t3 <- crossprod(Ginit[-j, ], as.matrix(invsigX[-j, j])) / invsigX[j, j]

          GUGt2 <- g + t2
          GUG <- GUG - tcrossprod(GUGt2, GUGt2) * sigXcY[j, j]

          GVGt2 <- g + t3
          GVG <- GVG - tcrossprod(GVGt2, GVGt2) * invsigX[j, j]

          t4 <- t4 - tcrossprod(g, g)
          #save(GUG,GVG,file='GUG.Rdata')
          invC1 <- chol2inv(sechol(GUG))
          invC2 <- chol2inv(sechol(GVG))

          invt4 <- chol2inv(sechol(t4))

          fobj <- function(x) {
            tmp2 <- x + t2
            tmp3 <- x + t3
            T1 <- invt4 %*% x
            T2 <- invC1 %*% tmp2
            T3 <- invC2 %*% tmp3
            -2 * log(1 + x %*% T1) + log(1 + sigXcY[j, j] * crossprod(tmp2, T2)) + log(1 + invsigX[j, j] * crossprod(tmp3, T3))
          }

          gobj <- function(x) {
            tmp2 <- x + t2
            tmp3 <- x + t3
            T1 <- invt4 %*% x
            T2 <- invC1 %*% tmp2
            T3 <- invC2 %*% tmp3
            -4 	* T1 / as.numeric(1 + x %*% T1) + 2 * T2 / as.numeric(1 / sigXcY[j, j] + crossprod(tmp2, T2)) + 2 * T3 / as.numeric(1 / invsigX[j, j] + crossprod(tmp3, T3))
          }

          res <- optim(Ginit[j,], fobj, gobj, method = "BFGS",control=list(reltol=1e-2))
          Ginit[j, ] <- res$par
          g <- as.matrix(Ginit[j, ])
          t4 <- t4 + tcrossprod(g, g)
          GUGt2 <- g + t2
          GUG <- GUG + tcrossprod(GUGt2, GUGt2) * sigXcY[j, j]

          GVGt2 <- g + t3
          GVG <- GVG + tcrossprod(GVGt2, GVGt2) * invsigX[j, j]

        }
        a <- qr(Ginit)
        Gamma <- qr.Q(a)
        obj5 <- obj(Gamma)
        if (abs(obj1 - obj5) < ftol * abs(obj1)) {
          break
        } else {
          obj1 <- obj5
          i <- i + 1
        }
      }
      if(verbose) cat('The number of iterations:',i,'.\n',sep='')
      Gamma0 <- qr.Q(a, complete = TRUE)[, (u+1):p]
    }

    Omega = crossprod(Gamma,sigX) %*% Gamma
    Omega0 = crossprod(Gamma0,sigX) %*% Gamma0
    SigX = Gamma %*% Omega %*% t(Gamma) + Gamma0 %*% Omega0 %*% t(Gamma0)
    eta = solve(Omega) %*% t(Gamma) %*% sigXY;
    beta = Gamma %*% eta
    mu = mY - t(beta) %*% mX;

    a = logdet(t(Gamma) %*% sigXcY %*% Gamma);
    b = logdet(t(Gamma) %*% invsigX %*% Gamma);
    l = n * (p + r) * (1 + log(2 * pi)) + n * (a + b + logDetsigX + logDetsigY)

    ModelOutput$mu = mu
    ModelOutput$beta = beta
    ModelOutput$Gamma = Gamma
    ModelOutput$Gamma0 = Gamma0
    ModelOutput$eta = eta
    ModelOutput$SigX = SigX
    ModelOutput$Omega = Omega
    ModelOutput$Omega0 = Omega0
    ModelOutput$sigYcX = sigYcX
    ModelOutput$loglik = - 0.5 * l
    ModelOutput$paramNum = r + u * r + p * (p + 1) / 2 + r * (r + 1) / 2
    ModelOutput$n = n
    if(asy==1){
      #---compute asymptotic variance and get the ratios---
      asyFm = kronecker(sigYcX, invsigX);
      asyFm = matrix(sqrt(diag(asyFm)), p, r);
      temp = kronecker(eta %*% solve(sigYcX) %*% t(eta), Omega0)+
        kronecker(Omega, solve(Omega0)) +
        kronecker(solve(Omega), Omega0) - 2 * kronecker(diag(u), diag(p - u))
      covMatrix = kronecker(sigYcX, Gamma %*% solve(Omega) %*% t(Gamma)) + kronecker(t(eta), Gamma0) %*% solve(temp) %*% kronecker(eta, t(Gamma0));
      asySE = matrix(sqrt(diag(covMatrix)), p, r)
      ModelOutput$covMatrix = covMatrix
      ModelOutput$asySE = asySE
      ModelOutput$ratio = asyFm / asySE
    }

  }
  class(ModelOutput) <- "xenv"
  ModelOutput$fit_time=as.numeric((proc.time()-t1)[3])
  return(ModelOutput)
}

