#' Fit the sparse envelope model.
#'
#' @details
#' This function fits the sparse envelope model to the responses using maximum likelihood estimation.
#' When the dimension of the envelope is between 1 and r-1, we implement the algorithm in Su Z, Zhu G, Chen X, and Yang Y (2016).
#' When the dimension is r, the envelope model degenerates to standard multivariate linear regression.
#' When the dimension is 0, it means that X and Y are uncorrelated, and the fitting is different.
#'
#' @param X Predictors. An n by p matrix, p is the number of predictors. The predictors can be univariate or multivariate, discrete or continuous.
#' @param Y Multivariate responses. An n by r matrix, r is the number of responses and n is the number of observations. The responses must be continuous variables.
#' @param u Dimension of the envelope. An integer between 0 and r.
#' @param lambda1 A user-supplied lambda sequence for the first stage.
#' @param lambda2 A user-supplied lambda sequence for the second stage.
#' @param maxiter Maximum number of iterations. Default value: 100.
#' @param ftol Tolerance parameter for F. Default value: 1e-4.
#' @param init The initial value for the envelope subspace. An r by u matrix. The default value is the one generated by the function initial_value.
#' @param verbose Flag for printing out the model fitting process, logical 0 or 1. Default value: 0.
#'
#'
#' @return
#' \item{alpha}{The estimated intercept in the envelope model. An r by 1 vector.}
#' \item{beta}{The envelope estimator of the regression coefficients. An r by p matrix.}
#' \item{Gamma}{The orthogonal basis of the envelope subspace. An r by u semi-orthogonal matrix.}
#' \item{Gamma0}{The orthogonal basis of the complement of the envelope subspace. An r by r-u semi-orthogonal matrix.}
#' \item{eta}{The coordinates of beta with respect to Gamma. A u by p matrix.}
#' \item{Sigma}{The envelope estimator of the error covariance matrix. An r by r matrix.}
#' \item{Omega}{The coordinates of Sigma with respect to Gamma. A u by u matrix.}
#' \item{Omega0}{The coordinates of Sigma with respect to Gamma0. An r-u by r-u matrix.}
#' \item{loglik}{The maximized log likelihood function. A real number.}
#' \item{paramNum}{The number of parameters in the envelope model. A positive integer.}
#' \item{sigRes}{The sample error covariance matrix. An r by r matrix.}
#' \item{sigY}{The sample response covariance matrix. An r by r matrix.}
#' \item{sigX}{The sample predictor covariance matrix. A p by p matrix.}
#' \item{n}{The number of observations in the data. A positive integer.}
#' \item{r}{The number of responses. A nonnegative integer.}
#' \item{u}{Dimension of the envelope. An integer between 0 and r.}
#' \item{p}{The number of predictors. A positive integer.}
#' \item{q}{The number of active responses. A positive integer.}
#' \item{where_1}{The active responses chosen by the sparse envelope model.}
#' \item{where_0}{The inactive responses chosen by the sparse envelope model.}
#' \item{lambda}{The tuning parameters chosen by BIC.}
#' \item{BIC_seq1}{The sequence of BIC in the first stage.}
#' \item{BIC_seq2}{The sequence of BIC in the second stage.}
#' \item{fit_time}{The time costs for fitting the sparse envelope model.}
#'
#' @references
#' The codes are implemented based on the algorithm in Su, Z., Zhu, G., Chen, X., and Yang, Y. (2016),
#' Sparse Envelope Model: Efficient Estimation and Response Variable Selection in Multivariate Linear Regression.
#' Biometrika. 103, 579-593.
#'
#' @author Guangyu Zhu <guangyuzhu@uri.edu>
#'
#'
#' @seealso \code{choose_spenv} for choosing the dimension of the envelope subspace and the tuning parameter.
#'
#' @examples
#' ## Berkeley
#' data(Berkeley)
#' X = Berkeley$X
#' Y2 = Berkeley$Y[, c(1, 2, 21, 23)]
#' m1 = spenv(X, Y2, 1)
#' asym.spenv(m1)
#' @export
spenv <- function(X, Y, u, lambda1=NULL,lambda2=NULL, ftol = 1e-4, maxiter = 1e2,verbose=0,init=NULL){
  t1 = proc.time()
  X = as.matrix(X)
  Y = as.matrix(Y)
  r = ncol(Y)
  if(u==0|u==r) {out=env(X,Y,u)}
  else{
    if(missing(lambda1)) lambda1 <- exp(seq(log(1),log(1e-5),len = 15))
    if(missing(lambda2)) lambda2 <- exp(seq(log(1),log(1e-5),len = 15))
    if(missing(init))  init =  initial_value(X,Y,u)
    GEidx = GE(init)
    newY = Y[, GEidx]
    newinit = init[GEidx,,drop = FALSE]

    m1 <- LassoLambda.spenv(X, newY, u, lambda=lambda1, ftol = ftol,
                            maxiter = maxiter, weight = rep(1,r-u),
                            init = newinit,verbose=verbose)
    #calculating weight
    Gammahat <- m1$Gamma
    w <- Gammahat %*% solve(Gammahat[1:u, ])
    w_norm <- 1/(rowSums(w^2)^2)[(u+1):r]
    #w_norm2 <- 1/(rowSums(Gammahat^2)^2)[(u+1):r]
    #print(w_norm/w_norm2)

    if(verbose) print(w_norm)
    #adaptive lasso step
    #cat('-----------Second Adaptive Lasso\n')
    #newinit = m1$Gamma;
    m2 <- LassoLambda.spenv(X, newY, u, lambda=lambda2, ftol = ftol,
                            maxiter = maxiter, weight = w_norm,
                            init = newinit,verbose=verbose)
    out = m2
    out$alpha = m2$alpha[order(GEidx),,drop=FALSE]
    out$Gamma = m2$Gamma[order(GEidx),,drop=FALSE]
    out$Gamma0 = m2$Gamma0[order(GEidx),,drop=FALSE]
    out$beta = m2$beta[order(GEidx),,drop=FALSE]
    out$where1 =  sort(GEidx[m2$where1])
    out$where0 =  setdiff(1:r,out$where1)
    out$BIC_seq = NULL
    out$BIC_seq1=m1$BIC_seq
    out$BIC_seq2=m2$BIC_seq
    out$sigRes=m2$sigRes[order(GEidx),order(GEidx)]
    out$sigY=m2$sigY[order(GEidx),order(GEidx)]
    lambdas=c(m1$lambda,m2$lambda)
    names(lambdas)=c('first stage','second stage')
    out$lambda=lambdas
  }
  out$fit_time = as.numeric((proc.time()-t1)[3])
  class(out)<-'spenv'
  out
}
